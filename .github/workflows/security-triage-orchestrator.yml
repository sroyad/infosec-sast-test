name: "Security Triage Orchestrator"

on:
  workflow_dispatch:
    inputs:
      auto_dismiss:
        description: 'Auto-dismiss false positives (true/false)'
        required: false
        type: boolean
        default: false
      max_alerts_per_repo:
        description: 'Maximum alerts to process per repository'
        required: false
        type: string
        default: '300'
      max_repos:
        description: 'Maximum repositories to process (0 = all, -1 = use test_repos list)'
        required: false
        type: string
        default: '-1'
      org_name:
        description: 'Organization name to scan (default: uses GITHUB_REPOSITORY_OWNER)'
        required: false
        type: string
        default: ''
      use_test_repos:
        description: 'Use hardcoded test repos list instead of discovery (true/false)'
        required: false
        type: boolean
        default: true  # Default to true to use hardcoded test repos
  schedule:
    - cron: "0 12 * * 0"  # Sundays 12:00 PM UTC

permissions:
  contents: read              # Read repository files
  security-events: write      # Read/dismiss security alerts (write permission includes read)
  actions: read              # Read workflow information

jobs:
  discover-repos-with-alerts:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: read    # Need read permission to discover alerts
      actions: read
    outputs:
      repos: ${{ steps.set-repos.outputs.repos }}
    steps:
      - name: Set up token
        id: token-setup
        run: |
          # Use PAT secret if available, otherwise use GITHUB_TOKEN
          if [ -n "${PAT_TOKEN}" ] && [ "${PAT_TOKEN}" != "" ]; then
            echo "üîë Using Personal Access Token (PAT) from secret"
            echo "token=${PAT_TOKEN}" >> $GITHUB_OUTPUT
            TOKEN_TYPE="PAT"
          else
            echo "üîë Using GITHUB_TOKEN (limited to current repository)"
            echo "‚ö†Ô∏è  Note: GITHUB_TOKEN can only access the current repository."
            echo "‚ö†Ô∏è  To access other repositories, create a secret named 'PAT_TOKEN' with a Personal Access Token."
            echo "token=${GITHUB_TOKEN}" >> $GITHUB_OUTPUT
            TOKEN_TYPE="GITHUB_TOKEN"
          fi
          echo "token_type=${TOKEN_TYPE}" >> $GITHUB_OUTPUT
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Verify GitHub token
        env:
          TOKEN: ${{ steps.token-setup.outputs.token }}
        run: |
          echo "üîê Verifying GitHub token..."
          response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/user")
          
          http_code=$(echo "${response}" | tail -n1)
          body=$(echo "${response}" | head -n-1)
          
          if [ "${http_code}" = "200" ]; then
            username=$(echo "${body}" | jq -r '.login // "unknown"' 2>/dev/null || echo "unknown")
            echo "‚úÖ GitHub token is valid (authenticated as: ${username}, type: ${{ steps.token-setup.outputs.token_type }})"
          else
            echo "‚ö†Ô∏è Warning: Token verification returned HTTP ${http_code}"
            echo "Response body: ${body}"
            echo "‚ö†Ô∏è Continuing anyway - actual API calls will validate the token"
          fi

      - name: Discover repositories with open CodeQL alerts
        id: discover
        env:
          ORG_NAME: ${{ inputs.org_name || github.repository_owner }}
          MAX_REPOS: ${{ inputs.max_repos || '-1' }}
          USE_TEST_REPOS: ${{ inputs.use_test_repos != false && 'true' || 'false' }}
          GITHUB_TOKEN: ${{ steps.token-setup.outputs.token }}
        run: |
          # Hardcoded list of repositories
          ORG_PREFIX="${ORG_NAME}/"
          
          # PROD REPOS (commented out for testing)
          # TEST_REPOS=(
          #   "${ORG_PREFIX}payment-methods-ui"
          #   "${ORG_PREFIX}subscription-ui"
          #   "${ORG_PREFIX}billing-pricebook-microui"
          #   "${ORG_PREFIX}prm-opportunities-ui"
          #   "${ORG_PREFIX}product-ui"
          #   "${ORG_PREFIX}authz"
          #   "${ORG_PREFIX}reporting-service"
          #   "${ORG_PREFIX}ad-checkout-ui"
          #   "${ORG_PREFIX}revenue-shares-ui"
          #   "${ORG_PREFIX}pricing"
          # )
          
          # TEST REPOS (for personal account testing)
          TEST_REPOS=(
            "${ORG_PREFIX}Lang-Detailed-Breakdown-Percent"
            "${ORG_PREFIX}test-repo-secret"
            "${ORG_PREFIX}demo-repo2"
            "${ORG_PREFIX}demo-repo1"
            "${ORG_PREFIX}python-codeql-fresh"
            "${ORG_PREFIX}python-codeql-demo"
            "${ORG_PREFIX}test-codeql-optimization"
            "${ORG_PREFIX}actions"
          )
          
          echo "üîç Discovering repositories with open CodeQL alerts in org: ${ORG_NAME}"
          
          repos_json="[]"
          
          # Use test repos list if enabled
          if [ "${USE_TEST_REPOS}" = "true" ] || [ "${MAX_REPOS}" = "-1" ]; then
            echo "üìã Using hardcoded test repositories list"
            for repo in "${TEST_REPOS[@]}"; do
              if [ -z "${repo}" ] || [[ "${repo}" =~ ^[[:space:]]*# ]]; then
                continue
              fi
              
              echo "üîç Checking ${repo} for open CodeQL alerts..."
              
              # First, check if the repository exists and is accessible
              repo_check_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo}")
              
              repo_check_code=$(echo "${repo_check_response}" | tail -n1)
              repo_check_body=$(echo "${repo_check_response}" | head -n-1)
              
              if [ "${repo_check_code}" = "200" ]; then
                echo "‚úÖ Repository ${repo} found."
              elif [ "${repo_check_code}" = "401" ]; then
                echo "‚ùå Authentication failed (HTTP 401) for ${repo}"
                echo "   This usually means GITHUB_TOKEN cannot access other repositories."
                echo "   üí° Solution: Provide a Personal Access Token (PAT) with 'repo' and 'security_events' scopes via the 'github_token' input."
                echo "   Skipping ${repo}"
                continue
              elif [ "${repo_check_code}" = "404" ]; then
                echo "‚ö†Ô∏è Repository ${repo} not found or no access, skipping. Response body: ${repo_check_body}"
                continue
              else
                echo "‚ö†Ô∏è Error checking repository ${repo} existence: HTTP ${repo_check_code}, skipping. Response body: ${repo_check_body}"
                continue
              fi

              # Check if code scanning is enabled for the repo
              code_scanning_status_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo}/code-scanning/alerts?per_page=1") # Just check if endpoint is accessible
              
              code_scanning_status_code=$(echo "${code_scanning_status_response}" | tail -n1)
              code_scanning_status_body=$(echo "${code_scanning_status_response}" | head -n-1)

              if [ "${code_scanning_status_code}" = "403" ]; then
                echo "‚ö†Ô∏è Code scanning is not enabled for ${repo} or token lacks 'security_events:read' permission, skipping. Response body: ${code_scanning_status_body}"
                continue
              elif [ "${code_scanning_status_code}" = "401" ]; then
                echo "‚ùå Authentication failed (HTTP 401) when checking code scanning for ${repo}"
                echo "   üí° Solution: Provide a Personal Access Token (PAT) with 'repo' and 'security_events' scopes via the 'github_token' input."
                echo "   Skipping ${repo}"
                continue
              elif [ "${code_scanning_status_code}" != "200" ]; then
                echo "‚ö†Ô∏è Error checking code scanning status for ${repo}: HTTP ${code_scanning_status_code}, skipping. Response body: ${code_scanning_status_body}"
                continue
              fi
              
              # Check if repo has open CodeQL alerts
              alerts_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo}/code-scanning/alerts?state=open&tool_name=CodeQL&per_page=100")
              
              alerts_code=$(echo "${alerts_response}" | tail -n1)
              alerts_body=$(echo "${alerts_response}" | head -n-1)
              
              if [ "${alerts_code}" = "200" ]; then
                actual_count=$(echo "${alerts_body}" | jq 'if type == "array" then length else 0 end' || echo "0")
                
                if [ "${actual_count}" -gt 0 ]; then
                  echo "‚úÖ Found ${actual_count} open CodeQL alerts in ${repo}"
                  repos_json=$(echo "${repos_json}" | jq --arg repo "${repo}" --arg count "${actual_count}" '. + [{"repo": $repo, "alert_count": ($count | tonumber)}]')
                else
                  echo "‚ÑπÔ∏è  No open CodeQL alerts from CodeQL tool in ${repo}, skipping. Response body: ${alerts_body}"
                fi
              else
                echo "‚ö†Ô∏è  Error fetching CodeQL alerts for ${repo}: HTTP ${alerts_code}, skipping. Response body: ${alerts_body}"
              fi
            done
          else
            # Dynamic discovery mode
            echo "üîç Using dynamic discovery mode"
            page=1
            repos_found=0
          
          while [ "${repos_found}" -lt "${MAX_REPOS}" ] || [ "${MAX_REPOS}" = "0" ]; do
            # Get repos with code scanning enabled
            response=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/orgs/${ORG_NAME}/repos?type=all&page=${page}&per_page=100&sort=updated")
            
            if [ "$(echo "${response}" | tail -n1)" = "401" ]; then
              echo "‚ùå Authentication failed (HTTP 401) when listing organization repositories"
              echo "   üí° Solution: Provide a Personal Access Token (PAT) with 'repo' scope via the 'github_token' input."
              break
            fi
            
            http_code=$(echo "${response}" | tail -n1)
            body=$(echo "${response}" | head -n-1)
            
            if [ "${http_code}" != "200" ]; then
              echo "‚ö†Ô∏è API error ${http_code}, stopping discovery"
              break
            fi
            
            repos_batch=$(echo "${body}" | jq -r '.[].full_name' || echo "")
            
            if [ -z "${repos_batch}" ] || [ "${repos_batch}" = "null" ]; then
              break
            fi
            
            # Check each repo for open CodeQL alerts
            while IFS= read -r repo_full_name; do
              if [ -z "${repo_full_name}" ]; then
                continue
              fi
              
              echo "üîç Checking ${repo_full_name} for open CodeQL alerts..."

              # First, check if the repository exists and is accessible
              repo_check_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo_full_name}")
              
              repo_check_code=$(echo "${repo_check_response}" | tail -n1)
              repo_check_body=$(echo "${repo_check_response}" | head -n-1)
              
              if [ "${repo_check_code}" = "200" ]; then
                echo "‚úÖ Repository ${repo_full_name} found."
              elif [ "${repo_check_code}" = "401" ]; then
                echo "‚ùå Authentication failed (HTTP 401) for ${repo_full_name}"
                echo "   üí° Solution: Provide a Personal Access Token (PAT) with 'repo' and 'security_events' scopes via the 'github_token' input."
                echo "   Skipping ${repo_full_name}"
                continue
              elif [ "${repo_check_code}" = "404" ]; then
                echo "‚ö†Ô∏è Repository ${repo_full_name} not found or no access, skipping. Response body: ${repo_check_body}"
                continue
              else
                echo "‚ö†Ô∏è Error checking repository ${repo_full_name} existence: HTTP ${repo_check_code}, skipping. Response body: ${repo_check_body}"
                continue
              fi

              # Check if code scanning is enabled for the repo
              code_scanning_status_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo_full_name}/code-scanning/alerts?per_page=1") # Just check if endpoint is accessible
              
              code_scanning_status_code=$(echo "${code_scanning_status_response}" | tail -n1)
              code_scanning_status_body=$(echo "${code_scanning_status_response}" | head -n-1)

              if [ "${code_scanning_status_code}" = "403" ]; then
                echo "‚ö†Ô∏è Code scanning is not enabled for ${repo_full_name} or token lacks 'security_events:read' permission, skipping. Response body: ${code_scanning_status_body}"
                continue
              elif [ "${code_scanning_status_code}" = "401" ]; then
                echo "‚ùå Authentication failed (HTTP 401) when checking code scanning for ${repo_full_name}"
                echo "   üí° Solution: Provide a Personal Access Token (PAT) with 'repo' and 'security_events' scopes via the 'github_token' input."
                echo "   Skipping ${repo_full_name}"
                continue
              elif [ "${code_scanning_status_code}" != "200" ]; then
                echo "‚ö†Ô∏è Error checking code scanning status for ${repo_full_name}: HTTP ${code_scanning_status_code}, skipping. Response body: ${code_scanning_status_body}"
                continue
              fi

              # Check if repo has open CodeQL alerts
              alerts_response=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${repo_full_name}/code-scanning/alerts?state=open&tool_name=CodeQL&per_page=100")
              
              alerts_code=$(echo "${alerts_response}" | tail -n1)
              alerts_body=$(echo "${alerts_response}" | head -n-1)
              
              if [ "${alerts_code}" = "200" ]; then
                actual_count=$(echo "${alerts_body}" | jq 'if type == "array" then length else 0 end' || echo "0")
                
                if [ "${actual_count}" -gt 0 ]; then
                  echo "‚úÖ Found ${actual_count} open CodeQL alerts in ${repo_full_name}"
                  repos_json=$(echo "${repos_json}" | jq --arg repo "${repo_full_name}" --arg count "${actual_count}" '. + [{"repo": $repo, "alert_count": ($count | tonumber)}]')
                  repos_found=$((repos_found + 1))
                  
                  if [ "${MAX_REPOS}" != "0" ] && [ "${repos_found}" -ge "${MAX_REPOS}" ]; then
                    break 2
                  fi
                else
                  echo "‚ÑπÔ∏è  No open CodeQL alerts from CodeQL tool in ${repo_full_name}, skipping. Response body: ${alerts_body}"
                fi
              else
                echo "‚ö†Ô∏è  Error fetching CodeQL alerts for ${repo_full_name}: HTTP ${alerts_code}, skipping. Response body: ${alerts_body}"
              fi
            done <<< "${repos_batch}"
            
            page=$((page + 1))
            done
          fi
          
          echo "${repos_json}" | jq .
          echo "üìä Total repositories with open CodeQL alerts: $(echo "${repos_json}" | jq 'length')"
          
          # Set output
          echo "repos<<EOF" >> $GITHUB_OUTPUT
          echo "${repos_json}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Set repos output
        id: set-repos
        run: |
          repos='${{ steps.discover.outputs.repos }}'
          if [ -z "${repos}" ] || [ "${repos}" = "null" ] || [ "${repos}" = "" ]; then
            repos="[]"
          fi
          # Use multi-line EOF syntax for JSON arrays to avoid "Invalid format" errors
          echo "repos<<EOF" >> $GITHUB_OUTPUT
          echo "${repos}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "üìä Repos to process: $(echo "${repos}" | jq 'length' || echo "0")"

  triage-repos:
    needs: discover-repos-with-alerts
    if: needs.discover-repos-with-alerts.outputs.repos != '[]' && needs.discover-repos-with-alerts.outputs.repos != 'null' && needs.discover-repos-with-alerts.outputs.repos != ''
    strategy:
      matrix:
        repo: ${{ fromJson(needs.discover-repos-with-alerts.outputs.repos) }}
      fail-fast: false
      max-parallel: 5  # Process 5 repos in parallel to avoid rate limits
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # Needed to dismiss alerts
    env:
      TARGET_REPO: ${{ matrix.repo.repo }}
      MAX_ALERTS: ${{ inputs.max_alerts_per_repo || '300' }}
      AUTO_DISMISS: ${{ inputs.auto_dismiss == true && 'true' || 'false' }}
    steps:
      - name: Parse repository owner and name
        id: parse-repo
        run: |
          REPO_FULL="${{ matrix.repo.repo }}"
          OWNER=$(echo "${REPO_FULL}" | cut -d'/' -f1)
          REPO=$(echo "${REPO_FULL}" | cut -d'/' -f2)
          
          echo "owner=${OWNER}" >> $GITHUB_OUTPUT
          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          echo "üìÇ Processing: ${OWNER}/${REPO}"

      - name: Set up token for triage
        id: token-triage
        run: |
          # Use PAT secret if available, otherwise use GITHUB_TOKEN
          if [ -n "${PAT_TOKEN}" ] && [ "${PAT_TOKEN}" != "" ]; then
            echo "üîë Using Personal Access Token (PAT) from secret for triage"
            echo "token=${PAT_TOKEN}" >> $GITHUB_OUTPUT
          else
            echo "üîë Using GITHUB_TOKEN for triage"
            echo "token=${GITHUB_TOKEN}" >> $GITHUB_OUTPUT
          fi
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Checkout central actions repository
        uses: actions/checkout@v4
        with:
          path: actions-repo
          fetch-depth: 0
          token: ${{ steps.token-triage.outputs.token }}

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo.repo }}
          path: target-repo
          fetch-depth: 0
          token: ${{ steps.token-triage.outputs.token }}

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl python3

      - name: Install Cursor Agent CLI
        run: |
          curl -fsS https://cursor.com/install | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

      - name: Validate Cursor
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        run: |
          cursor-agent --print --model "auto" --output-format text "ping" >/dev/null
          echo "‚úÖ Cursor agent ready"

      - name: Verify and prepare triage script
        run: |
          SCRIPT_PATH="actions-repo/.github/tools/simple_cursor_triage.sh"
          if [ ! -f "${SCRIPT_PATH}" ]; then
            echo "‚ùå Triage script not found at ${SCRIPT_PATH}"
            echo "üìÇ Available files in actions-repo/.github/tools/:"
            ls -la actions-repo/.github/tools/ || echo "Directory does not exist"
            exit 1
          fi
          chmod +x "${SCRIPT_PATH}"
          echo "‚úÖ Triage script found and made executable"

      - name: Run AI Triage on target repository
        working-directory: target-repo
        env:
          OWNER: ${{ steps.parse-repo.outputs.owner }}
          REPO: ${{ steps.parse-repo.outputs.repo }}
          GITHUB_TOKEN: ${{ steps.token-triage.outputs.token }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_MODEL: "auto"
          ALERT_STATE: "open"
          MAX_ALERTS: ${{ env.MAX_ALERTS }}
          AUTO_DISMISS: ${{ env.AUTO_DISMISS }}
          GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
        run: |
          echo "ü§ñ Starting AI triage for ${OWNER}/${REPO}"
          echo "üìä Alert count: ${{ matrix.repo.alert_count }}"
          echo "üìÇ Working directory: $(pwd)"
          
          # From target-repo, go up one level to workspace root, then to actions-repo
          SCRIPT_PATH="../actions-repo/.github/tools/simple_cursor_triage.sh"
          
          # Verify script exists before running
          if [ ! -f "${SCRIPT_PATH}" ]; then
            echo "‚ùå Script not found at ${SCRIPT_PATH}"
            echo "Current directory: $(pwd)"
            echo "Parent directory contents:"
            ls -la ../
            echo "Looking for script at: $(realpath "${SCRIPT_PATH}" 2>/dev/null || echo "path not found")"
            exit 1
          fi
          
          echo "‚úÖ Script found at: $(realpath "${SCRIPT_PATH}")"
          
          # Run the triage script from central repo
          bash "${SCRIPT_PATH}"

      - name: Upload triage results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: triage-results-${{ steps.parse-repo.outputs.owner }}-${{ steps.parse-repo.outputs.repo }}
          path: |
            target-repo/context-aware-triage.json
            target-repo/repository_security_profile.txt
          retention-days: 30
          if-no-files-found: ignore

      - name: Summary for repository
        if: always()
        run: |
          if [ -f "target-repo/context-aware-triage.json" ]; then
            total=$(jq 'length' target-repo/context-aware-triage.json)
            tp_count=$(jq '[.[] | select(.ai_label == "real_issue")] | length' target-repo/context-aware-triage.json)
            fp_count=$(jq '[.[] | select(.ai_label == "likely_false_positive")] | length' target-repo/context-aware-triage.json)
            dismissed_count=$(jq '[.[] | select(.dismissed == true)] | length' target-repo/context-aware-triage.json)
            
            echo "## üìä Triage Results: ${{ matrix.repo.repo }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Total alerts processed:** ${total}" >> $GITHUB_STEP_SUMMARY
            echo "- **Real issues:** ${tp_count}" >> $GITHUB_STEP_SUMMARY
            echo "- **False positives:** ${fp_count}" >> $GITHUB_STEP_SUMMARY
            echo "- **Auto-dismissed:** ${dismissed_count}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No results file found for ${{ matrix.repo.repo }}" >> $GITHUB_STEP_SUMMARY
          fi

  final-summary:
    needs: [discover-repos-with-alerts, triage-repos]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate final summary
        run: |
          echo "# üéâ Security Triage Orchestrator Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repositories processed:** Check individual job results above" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review triage results in artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. Check dismissed alerts in Security tab of each repository" >> $GITHUB_STEP_SUMMARY
          echo "3. Address real issues identified by AI triage" >> $GITHUB_STEP_SUMMARY

